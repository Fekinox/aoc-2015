(in-package :aoc-problems)

(defun combinations (n k)
  (cond
    ((= k 0) (list nil))
    ((< n k) (list nil))
    ((= n k)
     (let ((res nil))
       (dotimes (i n)
         (push i res))
       (list (nreverse res))))
    (t
     (let ((with (combinations (1- n) (1- k)))
           (without (combinations (1- n) k)))
       (nconc
        without
        (mapcar #'(lambda (w)
                    (append w (list (1- n)))) with))))))

(defun two-partitioner (exclude numbers target-weight)
  (let ((memo (make-hash-table :test #'equal)))
    (labels
        ((runner (i a)
           (multiple-value-bind
               (v present-p)
               (gethash (list i a) memo)
             (when present-p
               (return-from runner v)))
           (setf (gethash (list i a) memo)
                 (block main
                   (when (>= i (length numbers))
                     (return-from main (= a target-weight)))
                   (when (runner (1+ i) a)
                     (return-from main t))
                   (when (and (= (bit exclude i) 0)
                              (runner (1+ i) (+ a (aref numbers i))))
                     (return-from main t))
                   (return-from main nil)))))
      #'runner)))

(defun three-partitioner (exclude numbers target-weight)
  (let ((memo (make-hash-table :test #'equal)))
    (labels
        ((runner (i a b)
           (multiple-value-bind
               (v present-p)
               (gethash (list i a b) memo)
             (when present-p
               (return-from runner v)))
           (setf (gethash (list i a b) memo)
                 (block main
                   (when (>= i (length numbers))
                     (return-from main (= target-weight a b)))
                   (when (runner (1+ i) a b)
                     (return-from main t))
                   (when (and (= (bit exclude i) 0)
                              (runner (1+ i) (+ a (aref numbers i)) b))
                     (return-from main t))
                   (when (and (= (bit exclude i) 0)
                              (>= a (+ b (aref numbers i)))
                              (runner (1+ i) a (+ b (aref numbers i))))
                     (return-from main t))
                   (return-from main nil)))))
      #'runner)))

(defun aoc24 ()
  (let ((silver nil)
        (gold nil))
    (let* ((numbers (make-array 0 :adjustable t :fill-pointer 0))
           (total-weight 0)
           (target-weight-silver 0)
           (target-weight-gold 0)
           (memo-silver (make-hash-table :test #'equal))
           (memo-gold (make-hash-table :test #'equal))
           (set-to-stats
            (lambda (s)
              (let ((count 0)
                    (weight 0)
                    (ent 1))
                (dotimes (i (length numbers))
                  (when (= (bit s i) 1)
                    (incf count)
                    (incf weight (aref numbers i))
                    (setf ent (* ent (aref numbers i)))))
                (values count weight ent))))
           (next-set
            (lambda (s i)
              (let ((new-bs (copy-seq s)))
                (setf (bit new-bs i) 1)
                new-bs))))
      (aoc-utils:dolines
        line *standard-input*
        (let ((v (parse-integer line)))
          (vector-push-extend v numbers)
          (incf total-weight v)))
      (setf target-weight-silver (truncate total-weight 3))
      (setf target-weight-gold (truncate total-weight 4))
      (let ((combo-size 1))
        (loop
          (format t "~a~%" (>= combo-size (length numbers)))
          (dolist (combo (combinations (length numbers) combo-size))
            (let* ((bitset (make-array (length numbers) :element-type 'bit))
                   (tp-silver nil)
                   (tp-gold nil)
                   (entanglement 1)
                   (weight 0))
              (dolist (i combo)
                (setf (bit bitset i) 1)
                (let ((v (aref numbers i)))
                  (incf weight v)
                  (setf entanglement (* entanglement v))))
              (setf tp-silver (two-partitioner bitset numbers target-weight-silver)
                    tp-gold (three-partitioner bitset numbers target-weight-gold))
              (when (and
                      (= weight target-weight-silver)
                      (funcall tp-silver 0 0)
                      (or (null silver) (< entanglement silver)))
                (setf silver entanglement))
              (when (and
                      (= weight target-weight-gold)
                      (funcall tp-gold 0 0 0)
                      (or (null gold) (< entanglement gold)))
                (setf gold entanglement))))
          (when (or (and silver gold) (>= combo-size 8))
            (return))
          (incf combo-size))))
    (format *standard-output* "silver: ~A~%" silver)
    (format *standard-output* "gold: ~A~%" gold)))
