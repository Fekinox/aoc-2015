(in-package :aoc-problems)

(defun all-matches-pairs (regex target-string)
  (let ((matches (cl-ppcre:all-matches regex target-string))
        (res nil))
    (loop
      (when (null matches) (return (nreverse res)))
      (push (list (first matches) (second matches)) res)
      (setf matches (cddr matches)))))

(defun aoc19 ()
  (let ((silver 0)
        (gold 0))
    (let ((groups (aoc-utils:newline-separated-groups *standard-input*))
          (memo (make-hash-table :test #'equal))
          (replacements (make-hash-table :test #'equal))
          (replacement-molecules (make-hash-table :test #'equal))
          (atom-regex "[A-Z][a-z]?|e"))
      (dolist (rp (first groups))
        (let ((tokens (str:split " => " rp)))
          (push (second tokens) (gethash (first tokens) replacements nil))))
      (maphash #'(lambda (k v) (format t "~a ~a~%" k v)) replacements)
      (let* ((target-molecule (first (second groups)))
             (exploded (coerce (cl-ppcre:all-matches-as-strings atom-regex target-molecule) 'vector))
             (best-length 0))
        (dotimes (i (length exploded))
          (dolist (rp (gethash (aref exploded i) replacements))
            (let ((clone (copy-seq exploded)))
              (setf (aref clone i) rp)
              (setf (gethash (apply 'concatenate 'string (coerce clone 'list)) replacement-molecules) t))))
        (setf silver (hash-table-count replacement-molecules))
        (labels
            ((runner (m i j)
               (multiple-value-bind (v present-p) (gethash (list m i j) memo)
                 (when present-p (return-from runner v)))
               (let* ((target (subseq target-molecule i j))
                      (v
                       (multiple-value-bind (s e) (cl-ppcre:scan atom-regex m)
                         (if (= e (length m))
                             ;; single atom
                           (let ((match-counts (cl-ppcre:count-matches atom-regex target)))
                             (case match-counts
                               (0 nil)
                               (1 (if (string= m target) 0 nil))
                               (t (let ((best nil))
                                    (dolist (a (gethash m replacements))
                                      (let ((v (runner a i j)))
                                        (when (and v (or (null best) (< (1+ v) best)))
                                          (setf best (1+ v)))))
                                    best))))
                           ;; multiple atoms
                           (let ((first-atom (subseq m 0 e))
                                 (rest-atoms (subseq m e))
                                 (match-indices (all-matches-pairs atom-regex target)))
                             (if (< (length match-indices) 2)
                                 nil
                                 (let ((best nil))
                                   (dolist (sp (rest match-indices))
                                     (let ((left (runner first-atom i (+ i (first sp))))
                                           (right (runner rest-atoms (+ i (first sp)) j)))
                                       (when (and left right (or (null best) (< (+ left right) best)))
                                         (setf best (+ left right)))))
                                   best)))))))
                 (when (> (length target) best-length)
                   (setf best-length (length target))
                   (format t "~a~%" best-length))
                 (setf (gethash (list m i j) memo) v))))
          (setf gold (runner "e" 0 (length target-molecule))))))
    (format *standard-output* "silver: ~a~%" silver)
    (format *standard-output* "gold: ~a~%" gold)))
